<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<title>BlockPoker æµ‹è¯•é¢æ¿ï¼ˆä¿®å¤ MetaMask æç¤ºï¼‰</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body{font-family: system-ui, "Helvetica Neue", Arial; background:#0b1020; color:#e6eef8; padding:18px}
  input,button,select{padding:6px 8px;margin:6px;border-radius:6px;border:1px solid #334; background:#071022; color:#e6eef8}
  button {cursor:pointer}
  #log{height:300px; overflow:auto; background:#041026; border:1px solid #223; padding:8px; white-space:pre-wrap}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  label{min-width:80px}
  .small{font-size:0.9rem;color:#a9b7c6}
</style>
</head>
<body>
  <h2>ğŸƒ BlockPoker è°ƒè¯•é¢æ¿ï¼ˆæ”¯æŒ MetaMask & æ‰‹åŠ¨åœ°å€ï¼‰</h2>

  <div class="row">
    <label>å½“å‰åœ°å€</label>
    <input id="addr" value="0xAAA" size="20" />
    <button id="connectWalletBtn">è¿æ¥é’±åŒ… (MetaMask)</button>
    <button id="connectWsBtn">è¿æ¥ WebSocket</button>
    <span class="small" id="authStatus">æœªç™»å½•</span>
  </div>

  <div class="row">
    <label>åŒ¹é…</label>
    æ±  <input id="pool" value="default" size="8" />
    æ¡Œäººæ•° <input id="tableSize" value="2" size="2" />
    <button onclick="joinMatch()">åŠ å…¥åŒ¹é…</button>
    <button onclick="cancelMatch()">å–æ¶ˆåŒ¹é…</button>
  </div>

  <div class="row">
    <label>æ¸¸æˆæ“ä½œ</label>
    <button onclick="sendAction('bet',{amount:100})">ä¸‹æ³¨ 100</button>
    <button onclick="sendAction('fold',{})">å¼ƒç‰Œ</button>
  </div>

  <h3>ğŸ“¡ WebSocket</h3>
  <div class="row">
    <label>çŠ¶æ€</label>
    <span id="wsStatus">æœªè¿æ¥</span>
    <label style="min-width:60px">Token</label>
    <input id="token" style="width:420px" placeholder="å¦‚æœæœ‰ JWT å¯ç²˜è´´æˆ–ç”±é’±åŒ…ç™»å½•è‡ªåŠ¨å¡«å†™"/>
  </div>

  <h3>ğŸ“œ æ—¥å¿—</h3>
  <div id="log"></div>

<script>
/*
  è¯´æ˜ï¼š
  - æ”¯æŒ MetaMask ç™»å½•æµç¨‹ï¼ˆnonce -> personal_sign -> /auth/verifyï¼‰
  - å¦‚æœæ²¡æœ‰ MetaMaskï¼Œä¼šåˆ‡æ¢åˆ°â€œæ‰‹åŠ¨åœ°å€â€æ¨¡å¼ï¼Œä¸ä¼šå¼ºåˆ¶å¼¹çª—
  - WebSocket ä¼šåœ¨è¿æ¥æ—¶æŠŠ token ä½œä¸º query param ?token=... ï¼ˆä¸­é—´ä»¶éœ€æ”¯æŒï¼‰
  - HTTP è¯·æ±‚ï¼ˆåŠ å…¥åŒ¹é…/å–æ¶ˆï¼‰å¦‚æœ token å­˜åœ¨ï¼Œä¼šè‡ªåŠ¨å¸¦ Authorization header
*/

// CONFIGï¼šæ ¹æ®åç«¯å®é™…åœ°å€ä¿®æ”¹
const API_BASE = "http://localhost:8080";
const WS_BASE = "ws://localhost:8080/ws";

const logDiv = document.getElementById('log');
const addrInput = document.getElementById('addr');
const tokenInput = document.getElementById('token');
const authStatus = document.getElementById('authStatus');
const wsStatus = document.getElementById('wsStatus');
let ws = null;
let currentAddress = addrInput.value || "";
let jwtToken = "";

// æ—¥å¿—å‡½æ•°
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logDiv.innerText = `[${t}] ${msg}\n` + logDiv.innerText;
}

// æ£€æŸ¥æ˜¯å¦æœ‰ MetaMaskï¼ˆwindow.ethereumï¼‰
function hasMetaMask() {
  return typeof window.ethereum !== 'undefined' && !!window.ethereum.request;
}

// è¿æ¥ MetaMask å¹¶ç™»å½•ï¼ˆEIP-191 personal_sign é£æ ¼ï¼‰
async function connectWallet() {
  if (!hasMetaMask()) {
    log("âš ï¸ æœªæ£€æµ‹åˆ° MetaMaskï¼ˆæˆ–å…¶å®ƒ injected providerï¼‰ã€‚åˆ‡æ¢åˆ°æ‰‹åŠ¨åœ°å€æ¨¡å¼ã€‚");
    return;
  }

  try {
    // è¯·æ±‚è´¦æˆ·è®¿é—®
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    if (!accounts || accounts.length === 0) {
      log("âŒ æœªæˆæƒé’±åŒ…åœ°å€");
      return;
    }
    const address = accounts[0];
    addrInput.value = address;
    currentAddress = address;
    log("âœ… é’±åŒ…å·²è¿æ¥: " + address);

    // è·å–æœåŠ¡å™¨ nonce
    const nonceResp = await fetch(`${API_BASE}/auth/nonce?address=${encodeURIComponent(address)}`);
    if (!nonceResp.ok) {
      const txt = await nonceResp.text();
      log("âŒ è·å– nonce å¤±è´¥: " + txt);
      return;
    }
    const nonceJson = await nonceResp.json();
    const nonce = nonceJson.nonce || nonceJson.Nonce || nonceJson;
    const message = `Login to PokerServer: nonce-${nonce}`;
    log("ğŸ” å¾…ç­¾åæ¶ˆæ¯: " + message);

    // ä½¿ç”¨ personal_sign ç­¾åï¼ˆéƒ¨åˆ†é’±åŒ…éœ€è¦å‚æ•°é¡ºåºåï¼‰
    // å°è¯• multiple variants for compatibility
    let signature = "";
    try {
      // MetaMask prefers personal_sign(params: [msg, address])
      signature = await window.ethereum.request({
        method: 'personal_sign',
        params: [message, address],
      });
    } catch (err1) {
      // fallback try eth_sign
      try {
        signature = await window.ethereum.request({ method: 'eth_sign', params: [address, message] });
      } catch (err2) {
        log("âŒ ç­¾åå¤±è´¥: " + (err2 && err2.message ? err2.message : err1.message));
        return;
      }
    }

    // æäº¤ verify è·å– JWT
    const verifyResp = await fetch(`${API_BASE}/auth/verify`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({address, nonce, signature})
    });
    if (!verifyResp.ok) {
      const txt = await verifyResp.text();
      log("âŒ ç™»å½•éªŒè¯å¤±è´¥: " + txt);
      return;
    }
    const verifyJson = await verifyResp.json();
    jwtToken = verifyJson.token || "";
    tokenInput.value = jwtToken;
    authStatus.innerText = "å·²ç™»å½•ï¼ˆé’±åŒ…ï¼‰";
    log("âœ… ç™»å½•æˆåŠŸï¼ŒJWT å·²è·å–");
  } catch (err) {
    log("âŒ connectWallet é”™è¯¯: " + (err.message || err));
  }
}

// è¿æ¥ WebSocketï¼ˆä¼šåœ¨ URL ä¸­ä¼  tokenï¼Œå¦‚æœæœ‰ï¼‰
function connectWS() {
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
    log("âš ï¸ WS å·²å­˜åœ¨ï¼Œå…ˆæ–­å¼€å†é‡è¿");
    ws.close();
    ws = null;
  }
  const token = tokenInput.value.trim();
  // ä½¿ç”¨ token ä½œä¸º query paramï¼ˆä¸­é—´ä»¶éœ€æ”¯æŒï¼‰
  const url = token ? `${WS_BASE}?token=${encodeURIComponent(token)}` : WS_BASE;
  ws = new WebSocket(url);

  ws.onopen = () => {
    wsStatus.innerText = "å·²è¿æ¥";
    log("âœ… WebSocket å·²è¿æ¥: " + url);
    // å¦‚æœæ²¡æœ‰ JWTï¼Œä½†æœ‰åœ°å€ï¼Œä¸»åŠ¨æ³¨å†Œåœ°å€ï¼ˆåç«¯å¯æ”¯æŒ register æ¶ˆæ¯ï¼‰
    const addr = addrInput.value.trim();
    if (!token && addr) {
      const reg = { event: "register", data: { address: addr } };
      ws.send(JSON.stringify(reg));
      log("â¡ï¸ å·²é€šè¿‡ WS æ³¨å†Œåœ°å€: " + addr + "ï¼ˆéè®¤è¯æ¨¡å¼ï¼‰");
    }
  };

  ws.onmessage = (ev) => {
    try {
      const msg = JSON.parse(ev.data);
      log("ğŸ“© æ”¶åˆ°: " + JSON.stringify(msg));
    } catch (e) {
      log("âš ï¸ æ”¶åˆ°é JSON: " + ev.data);
    }
  };

  ws.onclose = () => {
    wsStatus.innerText = "æ–­å¼€";
    log("âŒ WebSocket å·²æ–­å¼€");
  };

  ws.onerror = (e) => {
    log("âš ï¸ WebSocket é”™è¯¯");
    console.error(e);
  };
}

// åŠ å…¥åŒ¹é…ï¼ˆHTTPï¼‰
async function joinMatch() {
  const address = addrInput.value.trim();
  const pool = document.getElementById('pool').value;
  const tableSize = parseInt(document.getElementById('tableSize').value) || 2;
  const body = { address, pool, tableSize };

  const headers = { 'Content-Type': 'application/json' };
  if (tokenInput.value.trim()) headers['Authorization'] = 'Bearer ' + tokenInput.value.trim();

  try {
    log("â¡ï¸ å‘èµ· /match/join è¯·æ±‚: " + JSON.stringify(body));
    const resp = await fetch(`${API_BASE}/match/join`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });
    const data = await resp.json();
    log("âœ… /match/join è¿”å›: " + JSON.stringify(data));
  } catch (err) {
    log("âŒ joinMatch é”™è¯¯: " + (err.message || err));
  }
}

// å–æ¶ˆåŒ¹é…
async function cancelMatch() {
  const address = addrInput.value.trim();
  const headers = { 'Content-Type': 'application/json' };
  if (tokenInput.value.trim()) headers['Authorization'] = 'Bearer ' + tokenInput.value.trim();

  try {
    log("â¡ï¸ å‘èµ· /match/cancel è¯·æ±‚: " + address);
    const resp = await fetch(`${API_BASE}/match/cancel`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ address }),
    });
    const data = await resp.json();
    log("âœ… /match/cancel è¿”å›: " + JSON.stringify(data));
  } catch (err) {
    log("âŒ cancelMatch é”™è¯¯: " + (err.message || err));
  }
}

// é€šè¿‡ WS å‘é€åŠ¨ä½œï¼ˆactionï¼‰
function sendAction(action, extra) {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    log("âš ï¸ WebSocket æœªè¿æ¥ï¼Œæ— æ³•å‘é€åŠ¨ä½œ");
    return;
  }
  const payload = Object.assign({ action }, extra || {});
  const msg = { event: "player_action", data: payload };
  ws.send(JSON.stringify(msg));
  log("â¡ï¸ WS å‘é€: " + JSON.stringify(msg));
}

// ç»‘å®šæŒ‰é’®äº‹ä»¶
document.getElementById('connectWalletBtn').addEventListener('click', connectWallet);
document.getElementById('connectWsBtn').addEventListener('click', connectWS);

// å¦‚æœé¡µé¢é¦–æ¬¡åŠ è½½æ£€æµ‹åˆ° MetaMaskï¼Œåˆ™è‡ªåŠ¨æç¤ºï¼ˆéå¼¹çª—ï¼‰
window.addEventListener('load', () => {
  if (hasMetaMask()) {
    log("æ£€æµ‹åˆ° MetaMaskï¼Œå¯ä½¿ç”¨ é’±åŒ…ç™»å½•ï¼ˆConnect Walletï¼‰");
  } else {
    log("æœªæ£€æµ‹åˆ° MetaMaskï¼Œé¡µé¢å·²è‡ªåŠ¨åˆ‡æ¢ä¸ºæ‰‹åŠ¨åœ°å€æ¨¡å¼ï¼ˆä¸ä¼šå¼¹çª—ï¼‰");
  }
});
</script>
</body>
</html>
